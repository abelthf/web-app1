'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _object = require('object.assign');

var _object2 = _interopRequireDefault(_object);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _server = require('react-dom/server');

var _server2 = _interopRequireDefault(_server);

var _shallow = require('react-test-renderer/shallow');

var _shallow2 = _interopRequireDefault(_shallow);

var _package = require('react-test-renderer/package.json');

var _testUtils = require('react-dom/test-utils');

var _testUtils2 = _interopRequireDefault(_testUtils);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _checkPropTypes2 = require('prop-types/checkPropTypes');

var _checkPropTypes3 = _interopRequireDefault(_checkPropTypes2);

var _has = require('has');

var _has2 = _interopRequireDefault(_has);

var _reactIs = require('react-is');

var _enzyme = require('enzyme');

var _Utils = require('enzyme/build/Utils');

var _enzymeShallowEqual = require('enzyme-shallow-equal');

var _enzymeShallowEqual2 = _interopRequireDefault(_enzymeShallowEqual);

var _enzymeAdapterUtils = require('enzyme-adapter-utils');

var _findCurrentFiberUsingSlowPath = require('./findCurrentFiberUsingSlowPath');

var _findCurrentFiberUsingSlowPath2 = _interopRequireDefault(_findCurrentFiberUsingSlowPath);

var _detectFiberTags = require('./detectFiberTags');

var _detectFiberTags2 = _interopRequireDefault(_detectFiberTags);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-use-before-define: 0 */

// eslint-disable-next-line import/no-unresolved

// eslint-disable-next-line import/no-unresolved

// eslint-disable-next-line import/no-unresolved


var is164 = !!_testUtils2['default'].Simulate.touchStart; // 16.4+
var is165 = !!_testUtils2['default'].Simulate.auxClick; // 16.5+
var is166 = is165 && !_react2['default'].unstable_AsyncMode; // 16.6+
var is168 = is166 && typeof _testUtils2['default'].act === 'function';

var hasShouldComponentUpdateBug = _semver2['default'].satisfies(_package.version, '< 16.8');

// Lazily populated if DOM is available.
var FiberTags = null;

function nodeAndSiblingsArray(nodeWithSibling) {
  var array = [];
  var node = nodeWithSibling;
  while (node != null) {
    array.push(node);
    node = node.sibling;
  }
  return array;
}

function flatten(arr) {
  var result = [];
  var stack = [{ i: 0, array: arr }];
  while (stack.length) {
    var n = stack.pop();
    while (n.i < n.array.length) {
      var el = n.array[n.i];
      n.i += 1;
      if (Array.isArray(el)) {
        stack.push(n);
        stack.push({ i: 0, array: el });
        break;
      }
      result.push(el);
    }
  }
  return result;
}

function nodeTypeFromType(type) {
  if (type === _reactIs.Portal) {
    return 'portal';
  }

  return (0, _enzymeAdapterUtils.nodeTypeFromType)(type);
}

function unmemoType(type) {
  return (0, _reactIs.isMemo)(type) ? type.type : type;
}

function elementToTree(el) {
  if (!(0, _reactIs.isPortal)(el)) {
    return (0, _enzymeAdapterUtils.elementToTree)(el, elementToTree);
  }

  var children = el.children,
      containerInfo = el.containerInfo;

  var props = { children: children, containerInfo: containerInfo };

  return {
    nodeType: 'portal',
    type: _reactIs.Portal,
    props: props,
    key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(el.key),
    ref: el.ref || null,
    instance: null,
    rendered: elementToTree(el.children)
  };
}

function _toTree(vnode) {
  if (vnode == null) {
    return null;
  }
  // TODO(lmr): I'm not really sure I understand whether or not this is what
  // i should be doing, or if this is a hack for something i'm doing wrong
  // somewhere else. Should talk to sebastian about this perhaps
  var node = (0, _findCurrentFiberUsingSlowPath2['default'])(vnode);
  switch (node.tag) {
    case FiberTags.HostRoot:
      return childrenToTree(node.child);
    case FiberTags.HostPortal:
      {
        var containerInfo = node.stateNode.containerInfo,
            children = node.memoizedProps;

        var props = { containerInfo: containerInfo, children: children };
        return {
          nodeType: 'portal',
          type: _reactIs.Portal,
          props: props,
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }
    case FiberTags.ClassComponent:
      return {
        nodeType: 'class',
        type: node.type,
        props: (0, _object2['default'])({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child)
      };
    case FiberTags.FunctionalComponent:
      return {
        nodeType: 'function',
        type: node.type,
        props: (0, _object2['default'])({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: null,
        rendered: childrenToTree(node.child)
      };
    case FiberTags.MemoClass:
      return {
        nodeType: 'class',
        type: node.elementType.type,
        props: (0, _object2['default'])({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child.child)
      };
    case FiberTags.MemoSFC:
      {
        var renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));
        if (renderedNodes.length === 0) {
          renderedNodes = [node.memoizedProps.children];
        }
        return {
          nodeType: 'function',
          type: node.elementType,
          props: (0, _object2['default'])({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: renderedNodes
        };
      }
    case FiberTags.HostComponent:
      {
        var _renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));
        if (_renderedNodes.length === 0) {
          _renderedNodes = [node.memoizedProps.children];
        }
        return {
          nodeType: 'host',
          type: node.type,
          props: (0, _object2['default'])({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: node.stateNode,
          rendered: _renderedNodes
        };
      }
    case FiberTags.HostText:
      return node.memoizedProps;
    case FiberTags.Fragment:
    case FiberTags.Mode:
    case FiberTags.ContextProvider:
    case FiberTags.ContextConsumer:
      return childrenToTree(node.child);
    case FiberTags.Profiler:
    case FiberTags.ForwardRef:
      {
        return {
          nodeType: 'function',
          type: node.type,
          props: (0, _object2['default'])({}, node.pendingProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }
    case FiberTags.Suspense:
      {
        return {
          nodeType: 'function',
          type: _reactIs.Suspense,
          props: (0, _object2['default'])({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }
    case FiberTags.Lazy:
      return childrenToTree(node.child);
    default:
      throw new Error('Enzyme Internal Error: unknown node with tag ' + String(node.tag));
  }
}

function childrenToTree(node) {
  if (!node) {
    return null;
  }
  var children = nodeAndSiblingsArray(node);
  if (children.length === 0) {
    return null;
  }
  if (children.length === 1) {
    return _toTree(children[0]);
  }
  return flatten(children.map(_toTree));
}

function _nodeToHostNode(_node) {
  // NOTE(lmr): node could be a function component
  // which wont have an instance prop, but we can get the
  // host node associated with its return value at that point.
  // Although this breaks down if the return value is an array,
  // as is possible with React 16.
  var node = _node;
  while (node && !Array.isArray(node) && node.instance === null) {
    node = node.rendered;
  }
  // if the SFC returned null effectively, there is no host node.
  if (!node) {
    return null;
  }

  var mapper = function mapper(item) {
    if (item && item.instance) return _reactDom2['default'].findDOMNode(item.instance);
    return null;
  };
  if (Array.isArray(node)) {
    return node.map(mapper);
  }
  if (Array.isArray(node.rendered) && node.nodeType === 'class') {
    return node.rendered.map(mapper);
  }
  return mapper(node);
}

function replaceLazyWithFallback(node, fallback) {
  if (!node) {
    return null;
  }
  if (Array.isArray(node)) {
    return node.map(function (el) {
      return replaceLazyWithFallback(el, fallback);
    });
  }
  if ((0, _reactIs.isLazy)(node.type)) {
    return fallback;
  }
  return (0, _object2['default'])({}, node, {
    props: (0, _object2['default'])({}, node.props, {
      children: replaceLazyWithFallback(node.props.children, fallback)
    })
  });
}

var eventOptions = {
  animation: true,
  pointerEvents: is164,
  auxClick: is165
};

function getEmptyStateValue() {
  // this handles a bug in React 16.0 - 16.2
  // see https://github.com/facebook/react/commit/39be83565c65f9c522150e52375167568a2a1459
  // also see https://github.com/facebook/react/pull/11965

  // eslint-disable-next-line react/prefer-stateless-function
  var EmptyState = function (_React$Component) {
    _inherits(EmptyState, _React$Component);

    function EmptyState() {
      _classCallCheck(this, EmptyState);

      return _possibleConstructorReturn(this, (EmptyState.__proto__ || Object.getPrototypeOf(EmptyState)).apply(this, arguments));
    }

    _createClass(EmptyState, [{
      key: 'render',
      value: function () {
        function render() {
          return null;
        }

        return render;
      }()
    }]);

    return EmptyState;
  }(_react2['default'].Component);

  var testRenderer = new _shallow2['default']();
  testRenderer.render(_react2['default'].createElement(EmptyState));
  return testRenderer._instance.state;
}

function wrapAct(fn) {
  if (!is168) {
    return fn();
  }
  var returnVal = void 0;
  _testUtils2['default'].act(function () {
    returnVal = fn();
  });
  return returnVal;
}

function getProviderDefaultValue(Provider) {
  // React stores references to the Provider's defaultValue differently across versions.
  if ('_defaultValue' in Provider._context) {
    return Provider._context._defaultValue;
  }
  if ('_currentValue' in Provider._context) {
    return Provider._context._currentValue;
  }
  throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');
}

function makeFakeElement(type) {
  return { $$typeof: _reactIs.Element, type: type };
}

function isStateful(Component) {
  return Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs) // fallback for createClass components
  );
}

var ReactSixteenAdapter = function (_EnzymeAdapter) {
  _inherits(ReactSixteenAdapter, _EnzymeAdapter);

  function ReactSixteenAdapter() {
    _classCallCheck(this, ReactSixteenAdapter);

    var _this2 = _possibleConstructorReturn(this, (ReactSixteenAdapter.__proto__ || Object.getPrototypeOf(ReactSixteenAdapter)).call(this));

    var lifecycles = _this2.options.lifecycles;

    _this2.options = (0, _object2['default'])({}, _this2.options, {
      enableComponentDidUpdateOnSetState: true, // TODO: remove, semver-major
      legacyContextMode: 'parent',
      lifecycles: (0, _object2['default'])({}, lifecycles, {
        componentDidUpdate: {
          onSetState: true
        },
        getDerivedStateFromProps: {
          hasShouldComponentUpdateBug: hasShouldComponentUpdateBug
        },
        getSnapshotBeforeUpdate: true,
        setState: {
          skipsComponentDidUpdateOnNullish: true
        },
        getChildContext: {
          calledByRenderer: false
        },
        getDerivedStateFromError: is166
      })
    });
    return _this2;
  }

  _createClass(ReactSixteenAdapter, [{
    key: 'createMountRenderer',
    value: function () {
      function createMountRenderer(options) {
        (0, _enzymeAdapterUtils.assertDomAvailable)('mount');
        if ((0, _has2['default'])(options, 'suspenseFallback')) {
          throw new TypeError('`suspenseFallback` is not supported by the `mount` renderer');
        }
        if (FiberTags === null) {
          // Requires DOM.
          FiberTags = (0, _detectFiberTags2['default'])();
        }
        var attachTo = options.attachTo,
            hydrateIn = options.hydrateIn,
            wrappingComponentProps = options.wrappingComponentProps;

        var domNode = hydrateIn || attachTo || global.document.createElement('div');
        var instance = null;
        var adapter = this;
        return (0, _object2['default'])({
          render: function () {
            function render(el, context, callback) {
              return wrapAct(function () {
                if (instance === null) {
                  var type = el.type,
                      props = el.props,
                      ref = el.ref;

                  var wrapperProps = (0, _object2['default'])({
                    Component: type,
                    props: props,
                    wrappingComponentProps: wrappingComponentProps,
                    context: context
                  }, ref && { ref: ref });
                  var ReactWrapperComponent = (0, _enzymeAdapterUtils.createMountWrapper)(el, (0, _object2['default'])({}, options, { adapter: adapter }));
                  var wrappedEl = _react2['default'].createElement(ReactWrapperComponent, wrapperProps);
                  instance = hydrateIn ? _reactDom2['default'].hydrate(wrappedEl, domNode) : _reactDom2['default'].render(wrappedEl, domNode);
                  if (typeof callback === 'function') {
                    callback();
                  }
                } else {
                  instance.setChildProps(el.props, context, callback);
                }
              });
            }

            return render;
          }(),
          unmount: function () {
            function unmount() {
              _reactDom2['default'].unmountComponentAtNode(domNode);
              instance = null;
            }

            return unmount;
          }(),
          getNode: function () {
            function getNode() {
              if (!instance) {
                return null;
              }
              return (0, _enzymeAdapterUtils.getNodeFromRootFinder)(adapter.isCustomComponent, _toTree(instance._reactInternalFiber), options);
            }

            return getNode;
          }(),
          simulateError: function () {
            function simulateError(nodeHierarchy, rootNode, error) {
              var isErrorBoundary = function () {
                function isErrorBoundary(_ref) {
                  var elInstance = _ref.instance,
                      type = _ref.type;

                  if (is166 && type && type.getDerivedStateFromError) {
                    return true;
                  }
                  return elInstance && elInstance.componentDidCatch;
                }

                return isErrorBoundary;
              }();

              var _ref2 = nodeHierarchy.find(isErrorBoundary) || {},
                  catchingInstance = _ref2.instance,
                  catchingType = _ref2.type;

              (0, _enzymeAdapterUtils.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode, is166 ? catchingType : undefined);
            }

            return simulateError;
          }(),
          simulateEvent: function () {
            function simulateEvent(node, event, mock) {
              var mappedEvent = (0, _enzymeAdapterUtils.mapNativeEventNames)(event, eventOptions);
              var eventFn = _testUtils2['default'].Simulate[mappedEvent];
              if (!eventFn) {
                throw new TypeError('ReactWrapper::simulate() event \'' + String(event) + '\' does not exist');
              }
              wrapAct(function () {
                eventFn(adapter.nodeToHostNode(node), mock);
              });
            }

            return simulateEvent;
          }(),
          batchedUpdates: function () {
            function batchedUpdates(fn) {
              return fn();
              // return ReactDOM.unstable_batchedUpdates(fn);
            }

            return batchedUpdates;
          }(),
          getWrappingComponentRenderer: function () {
            function getWrappingComponentRenderer() {
              return (0, _object2['default'])({}, this, (0, _enzymeAdapterUtils.getWrappingComponentMountRenderer)({
                toTree: function () {
                  function toTree(inst) {
                    return _toTree(inst._reactInternalFiber);
                  }

                  return toTree;
                }(),
                getMountWrapperInstance: function () {
                  function getMountWrapperInstance() {
                    return instance;
                  }

                  return getMountWrapperInstance;
                }()
              }));
            }

            return getWrappingComponentRenderer;
          }()
        }, is168 && { wrapInvoke: wrapAct });
      }

      return createMountRenderer;
    }()
  }, {
    key: 'createShallowRenderer',
    value: function () {
      function createShallowRenderer() {
        var _this4 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var adapter = this;
        var renderer = new _shallow2['default']();
        var suspenseFallback = options.suspenseFallback;

        if (typeof suspenseFallback !== 'undefined' && typeof suspenseFallback !== 'boolean') {
          throw TypeError('`options.suspenseFallback` should be boolean or undefined');
        }
        var isDOM = false;
        var cachedNode = null;

        var lastComponent = null;
        var wrappedComponent = null;
        var sentinel = {};

        // wrap memo components with a PureComponent, or a class component with sCU
        var wrapPureComponent = function () {
          function wrapPureComponent(Component, compare) {
            if (!is166) {
              throw new RangeError('this function should not be called in React < 16.6. Please report this!');
            }
            if (lastComponent !== Component) {
              if (isStateful(Component)) {
                wrappedComponent = function (_Component) {
                  _inherits(wrappedComponent, _Component);

                  function wrappedComponent() {
                    _classCallCheck(this, wrappedComponent);

                    return _possibleConstructorReturn(this, (wrappedComponent.__proto__ || Object.getPrototypeOf(wrappedComponent)).apply(this, arguments));
                  }

                  return wrappedComponent;
                }(Component); // eslint-disable-line react/prefer-stateless-function
                if (compare) {
                  wrappedComponent.prototype.shouldComponentUpdate = function (nextProps) {
                    return !compare(_this4.props, nextProps);
                  };
                } else {
                  wrappedComponent.prototype.isPureReactComponent = true;
                }
              } else {
                var memoized = sentinel;
                var prevProps = void 0;
                wrappedComponent = function () {
                  function wrappedComponent(props) {
                    var shouldUpdate = memoized === sentinel || (compare ? !compare(prevProps, props) : !(0, _enzymeShallowEqual2['default'])(prevProps, props));
                    if (shouldUpdate) {
                      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                      }

                      memoized = Component.apply(undefined, [(0, _object2['default'])({}, Component.defaultProps, props)].concat(args));
                      prevProps = props;
                    }
                    return memoized;
                  }

                  return wrappedComponent;
                }();
              }
              (0, _object2['default'])(wrappedComponent, Component, { displayName: adapter.displayNameOfNode({ type: Component }) });
              lastComponent = Component;
            }
            return wrappedComponent;
          }

          return wrapPureComponent;
        }();

        // Wrap functional components on versions prior to 16.5,
        // to avoid inadvertently pass a `this` instance to it.
        var wrapFunctionalComponent = function () {
          function wrapFunctionalComponent(Component) {
            if (is166 && (0, _has2['default'])(Component, 'defaultProps')) {
              if (lastComponent !== Component) {
                wrappedComponent = (0, _object2['default'])(
                // eslint-disable-next-line new-cap
                function (props) {
                  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    args[_key2 - 1] = arguments[_key2];
                  }

                  return Component.apply(undefined, [(0, _object2['default'])({}, Component.defaultProps, props)].concat(args));
                }, Component, { displayName: adapter.displayNameOfNode({ type: Component }) });
                lastComponent = Component;
              }
              return wrappedComponent;
            }
            if (is165) {
              return Component;
            }

            if (lastComponent !== Component) {
              wrappedComponent = (0, _object2['default'])(function () {
                return Component.apply(undefined, arguments);
              }, // eslint-disable-line new-cap
              Component);
              lastComponent = Component;
            }
            return wrappedComponent;
          }

          return wrapFunctionalComponent;
        }();

        return {
          render: function () {
            function render(el, unmaskedContext) {
              var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                  _ref3$providerValues = _ref3.providerValues,
                  providerValues = _ref3$providerValues === undefined ? new Map() : _ref3$providerValues;

              cachedNode = el;
              /* eslint consistent-return: 0 */
              if (typeof el.type === 'string') {
                isDOM = true;
              } else if ((0, _reactIs.isContextProvider)(el)) {
                providerValues.set(el.type, el.props.value);
                var MockProvider = (0, _object2['default'])(function (props) {
                  return props.children;
                }, el.type);
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render((0, _object2['default'])({}, el, { type: MockProvider }));
                });
              } else if ((0, _reactIs.isContextConsumer)(el)) {
                var Provider = adapter.getProviderFromConsumer(el.type);
                var value = providerValues.has(Provider) ? providerValues.get(Provider) : getProviderDefaultValue(Provider);
                var MockConsumer = (0, _object2['default'])(function (props) {
                  return props.children(value);
                }, el.type);
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render((0, _object2['default'])({}, el, { type: MockConsumer }));
                });
              } else {
                isDOM = false;
                var renderedEl = el;
                if ((0, _reactIs.isLazy)(renderedEl)) {
                  throw TypeError('`React.lazy` is not supported by shallow rendering.');
                }
                if ((0, _reactIs.isSuspense)(renderedEl)) {
                  var children = renderedEl.props.children;

                  if (suspenseFallback) {
                    var fallback = renderedEl.props.fallback;

                    children = replaceLazyWithFallback(children, fallback);
                  }
                  var FakeSuspenseWrapper = function () {
                    function FakeSuspenseWrapper() {
                      return children;
                    }

                    return FakeSuspenseWrapper;
                  }();
                  renderedEl = _react2['default'].createElement(FakeSuspenseWrapper, null, children);
                }
                var _renderedEl = renderedEl,
                    Component = _renderedEl.type;


                var context = (0, _enzymeAdapterUtils.getMaskedContext)(Component.contextTypes, unmaskedContext);

                if ((0, _reactIs.isMemo)(el.type)) {
                  var _el$type = el.type,
                      InnerComp = _el$type.type,
                      compare = _el$type.compare;


                  return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                    return renderer.render((0, _object2['default'])({}, el, { type: wrapPureComponent(InnerComp, compare) }), context);
                  });
                }

                if (!isStateful(Component) && typeof Component === 'function') {
                  return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                    return renderer.render((0, _object2['default'])({}, renderedEl, { type: wrapFunctionalComponent(Component) }), context);
                  });
                }

                if (isStateful) {
                  // fix react bug; see implementation of `getEmptyStateValue`
                  var emptyStateValue = getEmptyStateValue();
                  if (emptyStateValue) {
                    Object.defineProperty(Component.prototype, 'state', {
                      configurable: true,
                      enumerable: true,
                      get: function () {
                        function get() {
                          return null;
                        }

                        return get;
                      }(),
                      set: function () {
                        function set(value) {
                          if (value !== emptyStateValue) {
                            Object.defineProperty(this, 'state', {
                              configurable: true,
                              enumerable: true,
                              value: value,
                              writable: true
                            });
                          }
                          return true;
                        }

                        return set;
                      }()
                    });
                  }
                }
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render(renderedEl, context);
                });
              }
            }

            return render;
          }(),
          unmount: function () {
            function unmount() {
              renderer.unmount();
            }

            return unmount;
          }(),
          getNode: function () {
            function getNode() {
              if (isDOM) {
                return elementToTree(cachedNode);
              }
              var output = renderer.getRenderOutput();
              return {
                nodeType: nodeTypeFromType(cachedNode.type),
                type: cachedNode.type,
                props: cachedNode.props,
                key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(cachedNode.key),
                ref: cachedNode.ref,
                instance: renderer._instance,
                rendered: Array.isArray(output) ? flatten(output).map(function (el) {
                  return elementToTree(el);
                }) : elementToTree(output)
              };
            }

            return getNode;
          }(),
          simulateError: function () {
            function simulateError(nodeHierarchy, rootNode, error) {
              (0, _enzymeAdapterUtils.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode, is166 ? cachedNode.type : undefined);
            }

            return simulateError;
          }(),
          simulateEvent: function () {
            function simulateEvent(node, event) {
              for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                args[_key3 - 2] = arguments[_key3];
              }

              var handler = node.props[(0, _enzymeAdapterUtils.propFromEvent)(event, eventOptions)];
              if (handler) {
                (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  // TODO(lmr): create/use synthetic events
                  // TODO(lmr): emulate React's event propagation
                  // ReactDOM.unstable_batchedUpdates(() => {
                  handler.apply(undefined, _toConsumableArray(args));
                  // });
                });
              }
            }

            return simulateEvent;
          }(),
          batchedUpdates: function () {
            function batchedUpdates(fn) {
              return fn();
              // return ReactDOM.unstable_batchedUpdates(fn);
            }

            return batchedUpdates;
          }(),
          checkPropTypes: function () {
            function checkPropTypes(typeSpecs, values, location, hierarchy) {
              return (0, _checkPropTypes3['default'])(typeSpecs, values, location, (0, _enzymeAdapterUtils.displayNameOfNode)(cachedNode), function () {
                return (0, _enzymeAdapterUtils.getComponentStack)(hierarchy.concat([cachedNode]));
              });
            }

            return checkPropTypes;
          }()
        };
      }

      return createShallowRenderer;
    }()
  }, {
    key: 'createStringRenderer',
    value: function () {
      function createStringRenderer(options) {
        if ((0, _has2['default'])(options, 'suspenseFallback')) {
          throw new TypeError('`suspenseFallback` should not be specified in options of string renderer');
        }
        return {
          render: function () {
            function render(el, context) {
              if (options.context && (el.type.contextTypes || options.childContextTypes)) {
                var childContextTypes = (0, _object2['default'])({}, el.type.contextTypes || {}, options.childContextTypes);
                var ContextWrapper = (0, _enzymeAdapterUtils.createRenderWrapper)(el, context, childContextTypes);
                return _server2['default'].renderToStaticMarkup(_react2['default'].createElement(ContextWrapper));
              }
              return _server2['default'].renderToStaticMarkup(el);
            }

            return render;
          }()
        };
      }

      return createStringRenderer;
    }()

    // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation
    // specific, like `attach` etc. for React, but not part of this interface explicitly.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'createRenderer',
    value: function () {
      function createRenderer(options) {
        switch (options.mode) {
          case _enzyme.EnzymeAdapter.MODES.MOUNT:
            return this.createMountRenderer(options);
          case _enzyme.EnzymeAdapter.MODES.SHALLOW:
            return this.createShallowRenderer(options);
          case _enzyme.EnzymeAdapter.MODES.STRING:
            return this.createStringRenderer(options);
          default:
            throw new Error('Enzyme Internal Error: Unrecognized mode: ' + String(options.mode));
        }
      }

      return createRenderer;
    }()
  }, {
    key: 'wrap',
    value: function () {
      function wrap(element) {
        return (0, _enzymeAdapterUtils.wrap)(element);
      }

      return wrap;
    }()

    // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed
    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should
    // be pretty straightforward for people to implement.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'nodeToElement',
    value: function () {
      function nodeToElement(node) {
        if (!node || (typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') return null;
        var type = node.type;

        return _react2['default'].createElement(unmemoType(type), (0, _enzymeAdapterUtils.propsWithKeysAndRef)(node));
      }

      return nodeToElement;
    }()

    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'matchesElementType',
    value: function () {
      function matchesElementType(node, matchingType) {
        if (!node) {
          return node;
        }
        var type = node.type;

        return unmemoType(type) === unmemoType(matchingType);
      }

      return matchesElementType;
    }()
  }, {
    key: 'elementToNode',
    value: function () {
      function elementToNode(element) {
        return elementToTree(element);
      }

      return elementToNode;
    }()
  }, {
    key: 'nodeToHostNode',
    value: function () {
      function nodeToHostNode(node) {
        var supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var nodes = _nodeToHostNode(node);
        if (Array.isArray(nodes) && !supportsArray) {
          return nodes[0];
        }
        return nodes;
      }

      return nodeToHostNode;
    }()
  }, {
    key: 'displayNameOfNode',
    value: function () {
      function displayNameOfNode(node) {
        if (!node) return null;
        var type = node.type,
            $$typeof = node.$$typeof;


        var nodeType = type || $$typeof;

        // newer node types may be undefined, so only test if the nodeType exists
        if (nodeType) {
          switch (nodeType) {
            case (is166 ? _reactIs.ConcurrentMode : _reactIs.AsyncMode) || NaN:
              return is166 ? 'ConcurrentMode' : 'AsyncMode';
            case _reactIs.Fragment || NaN:
              return 'Fragment';
            case _reactIs.StrictMode || NaN:
              return 'StrictMode';
            case _reactIs.Profiler || NaN:
              return 'Profiler';
            case _reactIs.Portal || NaN:
              return 'Portal';
            case _reactIs.Suspense || NaN:
              return 'Suspense';
            default:
          }
        }

        var $$typeofType = type && type.$$typeof;

        switch ($$typeofType) {
          case _reactIs.ContextConsumer || NaN:
            return 'ContextConsumer';
          case _reactIs.ContextProvider || NaN:
            return 'ContextProvider';
          case _reactIs.Memo || NaN:
            {
              var nodeName = (0, _enzymeAdapterUtils.displayNameOfNode)(node);
              return typeof nodeName === 'string' ? nodeName : 'Memo(' + String((0, _enzymeAdapterUtils.displayNameOfNode)(type)) + ')';
            }
          case _reactIs.ForwardRef || NaN:
            {
              if (type.displayName) {
                return type.displayName;
              }
              var name = (0, _enzymeAdapterUtils.displayNameOfNode)({ type: type.render });
              return name ? 'ForwardRef(' + String(name) + ')' : 'ForwardRef';
            }
          case _reactIs.Lazy || NaN:
            {
              return 'lazy';
            }
          default:
            return (0, _enzymeAdapterUtils.displayNameOfNode)(node);
        }
      }

      return displayNameOfNode;
    }()
  }, {
    key: 'isValidElement',
    value: function () {
      function isValidElement(element) {
        return (0, _reactIs.isElement)(element);
      }

      return isValidElement;
    }()
  }, {
    key: 'isValidElementType',
    value: function () {
      function isValidElementType(object) {
        return !!object && (0, _reactIs.isValidElementType)(object);
      }

      return isValidElementType;
    }()
  }, {
    key: 'isFragment',
    value: function () {
      function isFragment(fragment) {
        return (0, _Utils.typeOfNode)(fragment) === _reactIs.Fragment;
      }

      return isFragment;
    }()
  }, {
    key: 'isCustomComponent',
    value: function () {
      function isCustomComponent(type) {
        var fakeElement = makeFakeElement(type);
        return !!type && (typeof type === 'function' || (0, _reactIs.isForwardRef)(fakeElement) || (0, _reactIs.isContextProvider)(fakeElement) || (0, _reactIs.isContextConsumer)(fakeElement) || (0, _reactIs.isSuspense)(fakeElement));
      }

      return isCustomComponent;
    }()
  }, {
    key: 'isContextConsumer',
    value: function () {
      function isContextConsumer(type) {
        return !!type && (0, _reactIs.isContextConsumer)(makeFakeElement(type));
      }

      return isContextConsumer;
    }()
  }, {
    key: 'isCustomComponentElement',
    value: function () {
      function isCustomComponentElement(inst) {
        if (!inst || !this.isValidElement(inst)) {
          return false;
        }
        return this.isCustomComponent(inst.type);
      }

      return isCustomComponentElement;
    }()
  }, {
    key: 'getProviderFromConsumer',
    value: function () {
      function getProviderFromConsumer(Consumer) {
        // React stores references to the Provider on a Consumer differently across versions.
        if (Consumer) {
          var Provider = void 0;
          if (Consumer._context) {
            Provider = Consumer._context.Provider; // check this first, to avoid a deprecation warning
          } else if (Consumer.Provider) {
            Provider = Consumer.Provider;
          }
          if (Provider) {
            return Provider;
          }
        }
        throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');
      }

      return getProviderFromConsumer;
    }()
  }, {
    key: 'createElement',
    value: function () {
      function createElement() {
        return _react2['default'].createElement.apply(_react2['default'], arguments);
      }

      return createElement;
    }()
  }, {
    key: 'wrapWithWrappingComponent',
    value: function () {
      function wrapWithWrappingComponent(node, options) {
        return {
          RootFinder: _enzymeAdapterUtils.RootFinder,
          node: (0, _enzymeAdapterUtils.wrapWithWrappingComponent)(_react2['default'].createElement, node, options)
        };
      }

      return wrapWithWrappingComponent;
    }()
  }]);

  return ReactSixteenAdapter;
}(_enzyme.EnzymeAdapter);

module.exports = ReactSixteenAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdFNpeHRlZW5BZGFwdGVyLmpzIl0sIm5hbWVzIjpbImlzMTY0IiwiVGVzdFV0aWxzIiwiU2ltdWxhdGUiLCJ0b3VjaFN0YXJ0IiwiaXMxNjUiLCJhdXhDbGljayIsImlzMTY2IiwiUmVhY3QiLCJ1bnN0YWJsZV9Bc3luY01vZGUiLCJpczE2OCIsImFjdCIsImhhc1Nob3VsZENvbXBvbmVudFVwZGF0ZUJ1ZyIsInNlbXZlciIsInNhdGlzZmllcyIsInRlc3RSZW5kZXJlclZlcnNpb24iLCJGaWJlclRhZ3MiLCJub2RlQW5kU2libGluZ3NBcnJheSIsIm5vZGVXaXRoU2libGluZyIsImFycmF5Iiwibm9kZSIsInB1c2giLCJzaWJsaW5nIiwiZmxhdHRlbiIsImFyciIsInJlc3VsdCIsInN0YWNrIiwiaSIsImxlbmd0aCIsIm4iLCJwb3AiLCJlbCIsIkFycmF5IiwiaXNBcnJheSIsIm5vZGVUeXBlRnJvbVR5cGUiLCJ0eXBlIiwiUG9ydGFsIiwidW5tZW1vVHlwZSIsImVsZW1lbnRUb1RyZWUiLCJjaGlsZHJlbiIsImNvbnRhaW5lckluZm8iLCJwcm9wcyIsIm5vZGVUeXBlIiwia2V5IiwicmVmIiwiaW5zdGFuY2UiLCJyZW5kZXJlZCIsInRvVHJlZSIsInZub2RlIiwidGFnIiwiSG9zdFJvb3QiLCJjaGlsZHJlblRvVHJlZSIsImNoaWxkIiwiSG9zdFBvcnRhbCIsInN0YXRlTm9kZSIsIm1lbW9pemVkUHJvcHMiLCJDbGFzc0NvbXBvbmVudCIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJNZW1vQ2xhc3MiLCJlbGVtZW50VHlwZSIsIk1lbW9TRkMiLCJyZW5kZXJlZE5vZGVzIiwibWFwIiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiRnJhZ21lbnQiLCJNb2RlIiwiQ29udGV4dFByb3ZpZGVyIiwiQ29udGV4dENvbnN1bWVyIiwiUHJvZmlsZXIiLCJGb3J3YXJkUmVmIiwicGVuZGluZ1Byb3BzIiwiU3VzcGVuc2UiLCJMYXp5IiwiRXJyb3IiLCJub2RlVG9Ib3N0Tm9kZSIsIl9ub2RlIiwibWFwcGVyIiwiaXRlbSIsIlJlYWN0RE9NIiwiZmluZERPTU5vZGUiLCJyZXBsYWNlTGF6eVdpdGhGYWxsYmFjayIsImZhbGxiYWNrIiwiZXZlbnRPcHRpb25zIiwiYW5pbWF0aW9uIiwicG9pbnRlckV2ZW50cyIsImdldEVtcHR5U3RhdGVWYWx1ZSIsIkVtcHR5U3RhdGUiLCJDb21wb25lbnQiLCJ0ZXN0UmVuZGVyZXIiLCJTaGFsbG93UmVuZGVyZXIiLCJyZW5kZXIiLCJjcmVhdGVFbGVtZW50IiwiX2luc3RhbmNlIiwic3RhdGUiLCJ3cmFwQWN0IiwiZm4iLCJyZXR1cm5WYWwiLCJnZXRQcm92aWRlckRlZmF1bHRWYWx1ZSIsIlByb3ZpZGVyIiwiX2NvbnRleHQiLCJfZGVmYXVsdFZhbHVlIiwiX2N1cnJlbnRWYWx1ZSIsIm1ha2VGYWtlRWxlbWVudCIsIiQkdHlwZW9mIiwiRWxlbWVudCIsImlzU3RhdGVmdWwiLCJwcm90b3R5cGUiLCJpc1JlYWN0Q29tcG9uZW50IiwiX19yZWFjdEF1dG9CaW5kUGFpcnMiLCJSZWFjdFNpeHRlZW5BZGFwdGVyIiwibGlmZWN5Y2xlcyIsIm9wdGlvbnMiLCJlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlIiwibGVnYWN5Q29udGV4dE1vZGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJvblNldFN0YXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJzZXRTdGF0ZSIsInNraXBzQ29tcG9uZW50RGlkVXBkYXRlT25OdWxsaXNoIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2FsbGVkQnlSZW5kZXJlciIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIlR5cGVFcnJvciIsImF0dGFjaFRvIiwiaHlkcmF0ZUluIiwid3JhcHBpbmdDb21wb25lbnRQcm9wcyIsImRvbU5vZGUiLCJnbG9iYWwiLCJkb2N1bWVudCIsImFkYXB0ZXIiLCJjb250ZXh0IiwiY2FsbGJhY2siLCJ3cmFwcGVyUHJvcHMiLCJSZWFjdFdyYXBwZXJDb21wb25lbnQiLCJ3cmFwcGVkRWwiLCJoeWRyYXRlIiwic2V0Q2hpbGRQcm9wcyIsInVubW91bnQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiZ2V0Tm9kZSIsImlzQ3VzdG9tQ29tcG9uZW50IiwiX3JlYWN0SW50ZXJuYWxGaWJlciIsInNpbXVsYXRlRXJyb3IiLCJub2RlSGllcmFyY2h5Iiwicm9vdE5vZGUiLCJlcnJvciIsImlzRXJyb3JCb3VuZGFyeSIsImVsSW5zdGFuY2UiLCJjb21wb25lbnREaWRDYXRjaCIsImZpbmQiLCJjYXRjaGluZ0luc3RhbmNlIiwiY2F0Y2hpbmdUeXBlIiwiZGlzcGxheU5hbWVPZk5vZGUiLCJ1bmRlZmluZWQiLCJzaW11bGF0ZUV2ZW50IiwiZXZlbnQiLCJtb2NrIiwibWFwcGVkRXZlbnQiLCJldmVudEZuIiwiYmF0Y2hlZFVwZGF0ZXMiLCJnZXRXcmFwcGluZ0NvbXBvbmVudFJlbmRlcmVyIiwiaW5zdCIsImdldE1vdW50V3JhcHBlckluc3RhbmNlIiwid3JhcEludm9rZSIsInJlbmRlcmVyIiwic3VzcGVuc2VGYWxsYmFjayIsImlzRE9NIiwiY2FjaGVkTm9kZSIsImxhc3RDb21wb25lbnQiLCJ3cmFwcGVkQ29tcG9uZW50Iiwic2VudGluZWwiLCJ3cmFwUHVyZUNvbXBvbmVudCIsImNvbXBhcmUiLCJSYW5nZUVycm9yIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwibmV4dFByb3BzIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJtZW1vaXplZCIsInByZXZQcm9wcyIsInNob3VsZFVwZGF0ZSIsImFyZ3MiLCJkZWZhdWx0UHJvcHMiLCJkaXNwbGF5TmFtZSIsIndyYXBGdW5jdGlvbmFsQ29tcG9uZW50IiwidW5tYXNrZWRDb250ZXh0IiwicHJvdmlkZXJWYWx1ZXMiLCJNYXAiLCJzZXQiLCJ2YWx1ZSIsIk1vY2tQcm92aWRlciIsImdldFByb3ZpZGVyRnJvbUNvbnN1bWVyIiwiaGFzIiwiZ2V0IiwiTW9ja0NvbnN1bWVyIiwicmVuZGVyZWRFbCIsIkZha2VTdXNwZW5zZVdyYXBwZXIiLCJjb250ZXh0VHlwZXMiLCJJbm5lckNvbXAiLCJlbXB0eVN0YXRlVmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIm91dHB1dCIsImdldFJlbmRlck91dHB1dCIsImNvbmNhdCIsImhhbmRsZXIiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImxvY2F0aW9uIiwiaGllcmFyY2h5IiwiY2hpbGRDb250ZXh0VHlwZXMiLCJDb250ZXh0V3JhcHBlciIsIlJlYWN0RE9NU2VydmVyIiwicmVuZGVyVG9TdGF0aWNNYXJrdXAiLCJtb2RlIiwiRW56eW1lQWRhcHRlciIsIk1PREVTIiwiTU9VTlQiLCJjcmVhdGVNb3VudFJlbmRlcmVyIiwiU0hBTExPVyIsImNyZWF0ZVNoYWxsb3dSZW5kZXJlciIsIlNUUklORyIsImNyZWF0ZVN0cmluZ1JlbmRlcmVyIiwiZWxlbWVudCIsIm1hdGNoaW5nVHlwZSIsInN1cHBvcnRzQXJyYXkiLCJub2RlcyIsIkNvbmN1cnJlbnRNb2RlIiwiQXN5bmNNb2RlIiwiTmFOIiwiU3RyaWN0TW9kZSIsIiQkdHlwZW9mVHlwZSIsIk1lbW8iLCJub2RlTmFtZSIsIm5hbWUiLCJvYmplY3QiLCJmcmFnbWVudCIsImZha2VFbGVtZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJDb25zdW1lciIsIlJvb3RGaW5kZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBRUE7Ozs7QUFDQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQXdCQTs7QUFDQTs7QUFDQTs7OztBQUNBOztBQXFCQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7K2VBOURBOztBQUdBOztBQUVBOztBQUdBOzs7QUF3REEsSUFBTUEsUUFBUSxD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SUFBVSxnQ0FBa0JvRSxnQkFBZ0JwRSxJQUFoQixDQUFsQixDQUFqQjtBQUNEOzs7Ozs7O3dDQUV3QmdJLEksRUFBTTtBQUM3QixZQUFJLENBQUNBLElBQUQsSUFBUyxDQUFDLEtBQUtnRixjQUFMLENBQW9CaEYsSUFBcEIsQ0FBZCxFQUF5QztBQUN2QyxpQkFBTyxLQUFQO0FBQ0Q7QUFDRCxlQUFPLEtBQUtyQixpQkFBTCxDQUF1QnFCLEtBQUtoSSxJQUE1QixDQUFQO0FBQ0Q7Ozs7Ozs7dUNBRXVCaU4sUSxFQUFVO0FBQ2hDO0FBQ0EsWUFBSUEsUUFBSixFQUFjO0FBQ1osY0FBSWpKLGlCQUFKO0FBQ0EsY0FBSWlKLFNBQVNoSixRQUFiLEVBQXVCO0FBQ2xCRCxvQkFEa0IsR0FDTGlKLFNBQVNoSixRQURKLENBQ2xCRCxRQURrQixFQUFFO0FBRXhCLFdBRkQsTUFFTyxJQUFJaUosU0FBU2pKLFFBQWIsRUFBdUI7QUFDekJBLG9CQUR5QixHQUNaaUosUUFEWSxDQUN6QmpKLFFBRHlCO0FBRTdCO0FBQ0QsY0FBSUEsUUFBSixFQUFjO0FBQ1osbUJBQU9BLFFBQVA7QUFDRDtBQUNGO0FBQ0QsY0FBTSxJQUFJekIsS0FBSixDQUFVLDJFQUFWLENBQU47QUFDRDs7Ozs7OzsrQkFFc0I7QUFDckIsZUFBT2xFLG1CQUFNb0YsYUFBTixxQ0FBUDtBQUNEOzs7Ozs7O3lDQUV5QnhFLEksRUFBTTRGLE8sRUFBUztBQUN2QyxlQUFPO0FBQ0xxSSxvREFESztBQUVMak8sZ0JBQU0sbURBQTBCWixtQkFBTW9GLGFBQWhDLEVBQStDeEUsSUFBL0MsRUFBcUQ0RixPQUFyRDtBQUZELFNBQVA7QUFJRDs7Ozs7OztFQTdnQitCNEcscUI7O0FBZ2hCbEMwQixPQUFPQyxPQUFQLEdBQWlCekksbUJBQWpCIiwiZmlsZSI6IlJlYWN0U2l4dGVlbkFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxuaW1wb3J0IFJlYWN0RE9NU2VydmVyIGZyb20gJ3JlYWN0LWRvbS9zZXJ2ZXInO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5pbXBvcnQgU2hhbGxvd1JlbmRlcmVyIGZyb20gJ3JlYWN0LXRlc3QtcmVuZGVyZXIvc2hhbGxvdyc7XG5pbXBvcnQgeyB2ZXJzaW9uIGFzIHRlc3RSZW5kZXJlclZlcnNpb24gfSBmcm9tICdyZWFjdC10ZXN0LXJlbmRlcmVyL3BhY2thZ2UuanNvbic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbmltcG9ydCBUZXN0VXRpbHMgZnJvbSAncmVhY3QtZG9tL3Rlc3QtdXRpbHMnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IGNoZWNrUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnO1xuaW1wb3J0IGhhcyBmcm9tICdoYXMnO1xuaW1wb3J0IHtcbiAgQXN5bmNNb2RlLFxuICBDb25jdXJyZW50TW9kZSxcbiAgQ29udGV4dENvbnN1bWVyLFxuICBDb250ZXh0UHJvdmlkZXIsXG4gIEVsZW1lbnQsXG4gIEZvcndhcmRSZWYsXG4gIEZyYWdtZW50LFxuICBpc0NvbnRleHRDb25zdW1lcixcbiAgaXNDb250ZXh0UHJvdmlkZXIsXG4gIGlzRWxlbWVudCxcbiAgaXNGb3J3YXJkUmVmLFxuICBpc0xhenksXG4gIGlzTWVtbyxcbiAgaXNQb3J0YWwsXG4gIGlzU3VzcGVuc2UsXG4gIGlzVmFsaWRFbGVtZW50VHlwZSxcbiAgTGF6eSxcbiAgTWVtbyxcbiAgUG9ydGFsLFxuICBQcm9maWxlcixcbiAgU3RyaWN0TW9kZSxcbiAgU3VzcGVuc2UsXG59IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCB7IEVuenltZUFkYXB0ZXIgfSBmcm9tICdlbnp5bWUnO1xuaW1wb3J0IHsgdHlwZU9mTm9kZSB9IGZyb20gJ2VuenltZS9idWlsZC9VdGlscyc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJ2VuenltZS1zaGFsbG93LWVxdWFsJztcbmltcG9ydCB7XG4gIGRpc3BsYXlOYW1lT2ZOb2RlLFxuICBlbGVtZW50VG9UcmVlIGFzIHV0aWxFbGVtZW50VG9UcmVlLFxuICBub2RlVHlwZUZyb21UeXBlIGFzIHV0aWxOb2RlVHlwZUZyb21UeXBlLFxuICBtYXBOYXRpdmVFdmVudE5hbWVzLFxuICBwcm9wRnJvbUV2ZW50LFxuICBhc3NlcnREb21BdmFpbGFibGUsXG4gIHdpdGhTZXRTdGF0ZUFsbG93ZWQsXG4gIGNyZWF0ZVJlbmRlcldyYXBwZXIsXG4gIGNyZWF0ZU1vdW50V3JhcHBlcixcbiAgcHJvcHNXaXRoS2V5c0FuZFJlZixcbiAgZW5zdXJlS2V5T3JVbmRlZmluZWQsXG4gIHNpbXVsYXRlRXJyb3IsXG4gIHdyYXAsXG4gIGdldE1hc2tlZENvbnRleHQsXG4gIGdldENvbXBvbmVudFN0YWNrLFxuICBSb290RmluZGVyLFxuICBnZXROb2RlRnJvbVJvb3RGaW5kZXIsXG4gIHdyYXBXaXRoV3JhcHBpbmdDb21wb25lbnQsXG4gIGdldFdyYXBwaW5nQ29tcG9uZW50TW91bnRSZW5kZXJlcixcbn0gZnJvbSAnZW56eW1lLWFkYXB0ZXItdXRpbHMnO1xuaW1wb3J0IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIGZyb20gJy4vZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgnO1xuaW1wb3J0IGRldGVjdEZpYmVyVGFncyBmcm9tICcuL2RldGVjdEZpYmVyVGFncyc7XG5cbmNvbnN0IGlzMTY0ID0gISFUZXN0VXRpbHMuU2ltdWxhdGUudG91Y2hTdGFydDsgLy8gMTYuNCtcbmNvbnN0IGlzMTY1ID0gISFUZXN0VXRpbHMuU2ltdWxhdGUuYXV4Q2xpY2s7IC8vIDE2LjUrXG5jb25zdCBpczE2NiA9IGlzMTY1ICYmICFSZWFjdC51bnN0YWJsZV9Bc3luY01vZGU7IC8vIDE2LjYrXG5jb25zdCBpczE2OCA9IGlzMTY2ICYmIHR5cGVvZiBUZXN0VXRpbHMuYWN0ID09PSAnZnVuY3Rpb24nO1xuXG5jb25zdCBoYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWcgPSBzZW12ZXIuc2F0aXNmaWVzKHRlc3RSZW5kZXJlclZlcnNpb24sICc8IDE2LjgnKTtcblxuLy8gTGF6aWx5IHBvcHVsYXRlZCBpZiBET00gaXMgYXZhaWxhYmxlLlxubGV0IEZpYmVyVGFncyA9IG51bGw7XG5cbmZ1bmN0aW9uIG5vZGVBbmRTaWJsaW5nc0FycmF5KG5vZGVXaXRoU2libGluZykge1xuICBjb25zdCBhcnJheSA9IFtdO1xuICBsZXQgbm9kZSA9IG5vZGVXaXRoU2libGluZztcbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGFycmF5LnB1c2gobm9kZSk7XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzdGFjayA9IFt7IGk6IDAsIGFycmF5OiBhcnIgfV07XG4gIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICBjb25zdCBuID0gc3RhY2sucG9wKCk7XG4gICAgd2hpbGUgKG4uaSA8IG4uYXJyYXkubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbCA9IG4uYXJyYXlbbi5pXTtcbiAgICAgIG4uaSArPSAxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XG4gICAgICAgIHN0YWNrLnB1c2gobik7XG4gICAgICAgIHN0YWNrLnB1c2goeyBpOiAwLCBhcnJheTogZWwgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBub2RlVHlwZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFBvcnRhbCkge1xuICAgIHJldHVybiAncG9ydGFsJztcbiAgfVxuXG4gIHJldHVybiB1dGlsTm9kZVR5cGVGcm9tVHlwZSh0eXBlKTtcbn1cblxuZnVuY3Rpb24gdW5tZW1vVHlwZSh0eXBlKSB7XG4gIHJldHVybiBpc01lbW8odHlwZSkgPyB0eXBlLnR5cGUgOiB0eXBlO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50VG9UcmVlKGVsKSB7XG4gIGlmICghaXNQb3J0YWwoZWwpKSB7XG4gICAgcmV0dXJuIHV0aWxFbGVtZW50VG9UcmVlKGVsLCBlbGVtZW50VG9UcmVlKTtcbiAgfVxuXG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRhaW5lckluZm8gfSA9IGVsO1xuICBjb25zdCBwcm9wcyA9IHsgY2hpbGRyZW4sIGNvbnRhaW5lckluZm8gfTtcblxuICByZXR1cm4ge1xuICAgIG5vZGVUeXBlOiAncG9ydGFsJyxcbiAgICB0eXBlOiBQb3J0YWwsXG4gICAgcHJvcHMsXG4gICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChlbC5rZXkpLFxuICAgIHJlZjogZWwucmVmIHx8IG51bGwsXG4gICAgaW5zdGFuY2U6IG51bGwsXG4gICAgcmVuZGVyZWQ6IGVsZW1lbnRUb1RyZWUoZWwuY2hpbGRyZW4pLFxuICB9O1xufVxuXG5mdW5jdGlvbiB0b1RyZWUodm5vZGUpIHtcbiAgaWYgKHZub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBUT0RPKGxtcik6IEknbSBub3QgcmVhbGx5IHN1cmUgSSB1bmRlcnN0YW5kIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgd2hhdFxuICAvLyBpIHNob3VsZCBiZSBkb2luZywgb3IgaWYgdGhpcyBpcyBhIGhhY2sgZm9yIHNvbWV0aGluZyBpJ20gZG9pbmcgd3JvbmdcbiAgLy8gc29tZXdoZXJlIGVsc2UuIFNob3VsZCB0YWxrIHRvIHNlYmFzdGlhbiBhYm91dCB0aGlzIHBlcmhhcHNcbiAgY29uc3Qgbm9kZSA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHZub2RlKTtcbiAgc3dpdGNoIChub2RlLnRhZykge1xuICAgIGNhc2UgRmliZXJUYWdzLkhvc3RSb290OlxuICAgICAgcmV0dXJuIGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpO1xuICAgIGNhc2UgRmliZXJUYWdzLkhvc3RQb3J0YWw6IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhdGVOb2RlOiB7IGNvbnRhaW5lckluZm8gfSxcbiAgICAgICAgbWVtb2l6ZWRQcm9wczogY2hpbGRyZW4sXG4gICAgICB9ID0gbm9kZTtcbiAgICAgIGNvbnN0IHByb3BzID0geyBjb250YWluZXJJbmZvLCBjaGlsZHJlbiB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdwb3J0YWwnLFxuICAgICAgICB0eXBlOiBQb3J0YWwsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgRmliZXJUYWdzLkNsYXNzQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdjbGFzcycsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbm9kZS5zdGF0ZU5vZGUsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgY2FzZSBGaWJlclRhZ3MuRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgY2FzZSBGaWJlclRhZ3MuTWVtb0NsYXNzOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdjbGFzcycsXG4gICAgICAgIHR5cGU6IG5vZGUuZWxlbWVudFR5cGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbm9kZS5zdGF0ZU5vZGUsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkLmNoaWxkKSxcbiAgICAgIH07XG4gICAgY2FzZSBGaWJlclRhZ3MuTWVtb1NGQzoge1xuICAgICAgbGV0IHJlbmRlcmVkTm9kZXMgPSBmbGF0dGVuKG5vZGVBbmRTaWJsaW5nc0FycmF5KG5vZGUuY2hpbGQpLm1hcCh0b1RyZWUpKTtcbiAgICAgIGlmIChyZW5kZXJlZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW5kZXJlZE5vZGVzID0gW25vZGUubWVtb2l6ZWRQcm9wcy5jaGlsZHJlbl07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdHlwZTogbm9kZS5lbGVtZW50VHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgcmVuZGVyZWQ6IHJlbmRlcmVkTm9kZXMsXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIEZpYmVyVGFncy5Ib3N0Q29tcG9uZW50OiB7XG4gICAgICBsZXQgcmVuZGVyZWROb2RlcyA9IGZsYXR0ZW4obm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZS5jaGlsZCkubWFwKHRvVHJlZSkpO1xuICAgICAgaWYgKHJlbmRlcmVkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbmRlcmVkTm9kZXMgPSBbbm9kZS5tZW1vaXplZFByb3BzLmNoaWxkcmVuXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnaG9zdCcsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbm9kZS5zdGF0ZU5vZGUsXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZE5vZGVzLFxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBGaWJlclRhZ3MuSG9zdFRleHQ6XG4gICAgICByZXR1cm4gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgIGNhc2UgRmliZXJUYWdzLkZyYWdtZW50OlxuICAgIGNhc2UgRmliZXJUYWdzLk1vZGU6XG4gICAgY2FzZSBGaWJlclRhZ3MuQ29udGV4dFByb3ZpZGVyOlxuICAgIGNhc2UgRmliZXJUYWdzLkNvbnRleHRDb25zdW1lcjpcbiAgICAgIHJldHVybiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKTtcbiAgICBjYXNlIEZpYmVyVGFncy5Qcm9maWxlcjpcbiAgICBjYXNlIEZpYmVyVGFncy5Gb3J3YXJkUmVmOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLnBlbmRpbmdQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgRmliZXJUYWdzLlN1c3BlbnNlOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdHlwZTogU3VzcGVuc2UsXG4gICAgICAgIHByb3BzOiB7IC4uLm5vZGUubWVtb2l6ZWRQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgRmliZXJUYWdzLkxhenk6XG4gICAgICByZXR1cm4gY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW56eW1lIEludGVybmFsIEVycm9yOiB1bmtub3duIG5vZGUgd2l0aCB0YWcgJHtub2RlLnRhZ31gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGlsZHJlblRvVHJlZShub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZSk7XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRvVHJlZShjaGlsZHJlblswXSk7XG4gIH1cbiAgcmV0dXJuIGZsYXR0ZW4oY2hpbGRyZW4ubWFwKHRvVHJlZSkpO1xufVxuXG5mdW5jdGlvbiBub2RlVG9Ib3N0Tm9kZShfbm9kZSkge1xuICAvLyBOT1RFKGxtcik6IG5vZGUgY291bGQgYmUgYSBmdW5jdGlvbiBjb21wb25lbnRcbiAgLy8gd2hpY2ggd29udCBoYXZlIGFuIGluc3RhbmNlIHByb3AsIGJ1dCB3ZSBjYW4gZ2V0IHRoZVxuICAvLyBob3N0IG5vZGUgYXNzb2NpYXRlZCB3aXRoIGl0cyByZXR1cm4gdmFsdWUgYXQgdGhhdCBwb2ludC5cbiAgLy8gQWx0aG91Z2ggdGhpcyBicmVha3MgZG93biBpZiB0aGUgcmV0dXJuIHZhbHVlIGlzIGFuIGFycmF5LFxuICAvLyBhcyBpcyBwb3NzaWJsZSB3aXRoIFJlYWN0IDE2LlxuICBsZXQgbm9kZSA9IF9ub2RlO1xuICB3aGlsZSAobm9kZSAmJiAhQXJyYXkuaXNBcnJheShub2RlKSAmJiBub2RlLmluc3RhbmNlID09PSBudWxsKSB7XG4gICAgbm9kZSA9IG5vZGUucmVuZGVyZWQ7XG4gIH1cbiAgLy8gaWYgdGhlIFNGQyByZXR1cm5lZCBudWxsIGVmZmVjdGl2ZWx5LCB0aGVyZSBpcyBubyBob3N0IG5vZGUuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgbWFwcGVyID0gKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSAmJiBpdGVtLmluc3RhbmNlKSByZXR1cm4gUmVhY3RET00uZmluZERPTU5vZGUoaXRlbS5pbnN0YW5jZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUubWFwKG1hcHBlcik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5yZW5kZXJlZCkgJiYgbm9kZS5ub2RlVHlwZSA9PT0gJ2NsYXNzJykge1xuICAgIHJldHVybiBub2RlLnJlbmRlcmVkLm1hcChtYXBwZXIpO1xuICB9XG4gIHJldHVybiBtYXBwZXIobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VMYXp5V2l0aEZhbGxiYWNrKG5vZGUsIGZhbGxiYWNrKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUubWFwKChlbCkgPT4gcmVwbGFjZUxhenlXaXRoRmFsbGJhY2soZWwsIGZhbGxiYWNrKSk7XG4gIH1cbiAgaWYgKGlzTGF6eShub2RlLnR5cGUpKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4ubm9kZSxcbiAgICBwcm9wczoge1xuICAgICAgLi4ubm9kZS5wcm9wcyxcbiAgICAgIGNoaWxkcmVuOiByZXBsYWNlTGF6eVdpdGhGYWxsYmFjayhub2RlLnByb3BzLmNoaWxkcmVuLCBmYWxsYmFjayksXG4gICAgfSxcbiAgfTtcbn1cblxuY29uc3QgZXZlbnRPcHRpb25zID0ge1xuICBhbmltYXRpb246IHRydWUsXG4gIHBvaW50ZXJFdmVudHM6IGlzMTY0LFxuICBhdXhDbGljazogaXMxNjUsXG59O1xuXG5mdW5jdGlvbiBnZXRFbXB0eVN0YXRlVmFsdWUoKSB7XG4gIC8vIHRoaXMgaGFuZGxlcyBhIGJ1ZyBpbiBSZWFjdCAxNi4wIC0gMTYuMlxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2NvbW1pdC8zOWJlODM1NjVjNjVmOWM1MjIxNTBlNTIzNzUxNjc1NjhhMmExNDU5XG4gIC8vIGFsc28gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExOTY1XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3ByZWZlci1zdGF0ZWxlc3MtZnVuY3Rpb25cbiAgY2xhc3MgRW1wdHlTdGF0ZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRlc3RSZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcbiAgdGVzdFJlbmRlcmVyLnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KEVtcHR5U3RhdGUpKTtcbiAgcmV0dXJuIHRlc3RSZW5kZXJlci5faW5zdGFuY2Uuc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHdyYXBBY3QoZm4pIHtcbiAgaWYgKCFpczE2OCkge1xuICAgIHJldHVybiBmbigpO1xuICB9XG4gIGxldCByZXR1cm5WYWw7XG4gIFRlc3RVdGlscy5hY3QoKCkgPT4geyByZXR1cm5WYWwgPSBmbigpOyB9KTtcbiAgcmV0dXJuIHJldHVyblZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdmlkZXJEZWZhdWx0VmFsdWUoUHJvdmlkZXIpIHtcbiAgLy8gUmVhY3Qgc3RvcmVzIHJlZmVyZW5jZXMgdG8gdGhlIFByb3ZpZGVyJ3MgZGVmYXVsdFZhbHVlIGRpZmZlcmVudGx5IGFjcm9zcyB2ZXJzaW9ucy5cbiAgaWYgKCdfZGVmYXVsdFZhbHVlJyBpbiBQcm92aWRlci5fY29udGV4dCkge1xuICAgIHJldHVybiBQcm92aWRlci5fY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuICB9XG4gIGlmICgnX2N1cnJlbnRWYWx1ZScgaW4gUHJvdmlkZXIuX2NvbnRleHQpIHtcbiAgICByZXR1cm4gUHJvdmlkZXIuX2NvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0VuenltZSBJbnRlcm5hbCBFcnJvcjogY2Fu4oCZdCBmaWd1cmUgb3V0IGhvdyB0byBnZXQgUHJvdmlkZXLigJlzIGRlZmF1bHQgdmFsdWUnKTtcbn1cblxuZnVuY3Rpb24gbWFrZUZha2VFbGVtZW50KHR5cGUpIHtcbiAgcmV0dXJuIHsgJCR0eXBlb2Y6IEVsZW1lbnQsIHR5cGUgfTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0ZWZ1bChDb21wb25lbnQpIHtcbiAgcmV0dXJuIENvbXBvbmVudC5wcm90b3R5cGUgJiYgKFxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudFxuICAgIHx8IEFycmF5LmlzQXJyYXkoQ29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzKSAvLyBmYWxsYmFjayBmb3IgY3JlYXRlQ2xhc3MgY29tcG9uZW50c1xuICApO1xufVxuXG5jbGFzcyBSZWFjdFNpeHRlZW5BZGFwdGVyIGV4dGVuZHMgRW56eW1lQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgeyBsaWZlY3ljbGVzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgZW5hYmxlQ29tcG9uZW50RGlkVXBkYXRlT25TZXRTdGF0ZTogdHJ1ZSwgLy8gVE9ETzogcmVtb3ZlLCBzZW12ZXItbWFqb3JcbiAgICAgIGxlZ2FjeUNvbnRleHRNb2RlOiAncGFyZW50JyxcbiAgICAgIGxpZmVjeWNsZXM6IHtcbiAgICAgICAgLi4ubGlmZWN5Y2xlcyxcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlOiB7XG4gICAgICAgICAgb25TZXRTdGF0ZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB7XG4gICAgICAgICAgaGFzU2hvdWxkQ29tcG9uZW50VXBkYXRlQnVnLFxuICAgICAgICB9LFxuICAgICAgICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgc2V0U3RhdGU6IHtcbiAgICAgICAgICBza2lwc0NvbXBvbmVudERpZFVwZGF0ZU9uTnVsbGlzaDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0OiB7XG4gICAgICAgICAgY2FsbGVkQnlSZW5kZXJlcjogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogaXMxNjYsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjcmVhdGVNb3VudFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICBhc3NlcnREb21BdmFpbGFibGUoJ21vdW50Jyk7XG4gICAgaWYgKGhhcyhvcHRpb25zLCAnc3VzcGVuc2VGYWxsYmFjaycpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgc3VzcGVuc2VGYWxsYmFja2AgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYG1vdW50YCByZW5kZXJlcicpO1xuICAgIH1cbiAgICBpZiAoRmliZXJUYWdzID09PSBudWxsKSB7XG4gICAgICAvLyBSZXF1aXJlcyBET00uXG4gICAgICBGaWJlclRhZ3MgPSBkZXRlY3RGaWJlclRhZ3MoKTtcbiAgICB9XG4gICAgY29uc3QgeyBhdHRhY2hUbywgaHlkcmF0ZUluLCB3cmFwcGluZ0NvbXBvbmVudFByb3BzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRvbU5vZGUgPSBoeWRyYXRlSW4gfHwgYXR0YWNoVG8gfHwgZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBpbnN0YW5jZSA9IG51bGw7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcihlbCwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHdyYXBBY3QoKCkgPT4ge1xuICAgICAgICAgIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcmVmIH0gPSBlbDtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgQ29tcG9uZW50OiB0eXBlLFxuICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgd3JhcHBpbmdDb21wb25lbnRQcm9wcyxcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgLi4uKHJlZiAmJiB7IHJlZiB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBSZWFjdFdyYXBwZXJDb21wb25lbnQgPSBjcmVhdGVNb3VudFdyYXBwZXIoZWwsIHsgLi4ub3B0aW9ucywgYWRhcHRlciB9KTtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRFbCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3RXcmFwcGVyQ29tcG9uZW50LCB3cmFwcGVyUHJvcHMpO1xuICAgICAgICAgICAgaW5zdGFuY2UgPSBoeWRyYXRlSW5cbiAgICAgICAgICAgICAgPyBSZWFjdERPTS5oeWRyYXRlKHdyYXBwZWRFbCwgZG9tTm9kZSlcbiAgICAgICAgICAgICAgOiBSZWFjdERPTS5yZW5kZXIod3JhcHBlZEVsLCBkb21Ob2RlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0Q2hpbGRQcm9wcyhlbC5wcm9wcywgY29udGV4dCwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZShkb21Ob2RlKTtcbiAgICAgICAgaW5zdGFuY2UgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGdldE5vZGUoKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0Tm9kZUZyb21Sb290RmluZGVyKFxuICAgICAgICAgIGFkYXB0ZXIuaXNDdXN0b21Db21wb25lbnQsXG4gICAgICAgICAgdG9UcmVlKGluc3RhbmNlLl9yZWFjdEludGVybmFsRmliZXIpLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFcnJvcihub2RlSGllcmFyY2h5LCByb290Tm9kZSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgaXNFcnJvckJvdW5kYXJ5ID0gKHsgaW5zdGFuY2U6IGVsSW5zdGFuY2UsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgIGlmIChpczE2NiAmJiB0eXBlICYmIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVsSW5zdGFuY2UgJiYgZWxJbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaW5zdGFuY2U6IGNhdGNoaW5nSW5zdGFuY2UsXG4gICAgICAgICAgdHlwZTogY2F0Y2hpbmdUeXBlLFxuICAgICAgICB9ID0gbm9kZUhpZXJhcmNoeS5maW5kKGlzRXJyb3JCb3VuZGFyeSkgfHwge307XG5cbiAgICAgICAgc2ltdWxhdGVFcnJvcihcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBjYXRjaGluZ0luc3RhbmNlLFxuICAgICAgICAgIHJvb3ROb2RlLFxuICAgICAgICAgIG5vZGVIaWVyYXJjaHksXG4gICAgICAgICAgbm9kZVR5cGVGcm9tVHlwZSxcbiAgICAgICAgICBhZGFwdGVyLmRpc3BsYXlOYW1lT2ZOb2RlLFxuICAgICAgICAgIGlzMTY2ID8gY2F0Y2hpbmdUeXBlIDogdW5kZWZpbmVkLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHNpbXVsYXRlRXZlbnQobm9kZSwgZXZlbnQsIG1vY2spIHtcbiAgICAgICAgY29uc3QgbWFwcGVkRXZlbnQgPSBtYXBOYXRpdmVFdmVudE5hbWVzKGV2ZW50LCBldmVudE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBldmVudEZuID0gVGVzdFV0aWxzLlNpbXVsYXRlW21hcHBlZEV2ZW50XTtcbiAgICAgICAgaWYgKCFldmVudEZuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVhY3RXcmFwcGVyOjpzaW11bGF0ZSgpIGV2ZW50ICcke2V2ZW50fScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwQWN0KCgpID0+IHtcbiAgICAgICAgICBldmVudEZuKGFkYXB0ZXIubm9kZVRvSG9zdE5vZGUobm9kZSksIG1vY2spO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBiYXRjaGVkVXBkYXRlcyhmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgLy8gcmV0dXJuIFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGZuKTtcbiAgICAgIH0sXG4gICAgICBnZXRXcmFwcGluZ0NvbXBvbmVudFJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRoaXMsXG4gICAgICAgICAgLi4uZ2V0V3JhcHBpbmdDb21wb25lbnRNb3VudFJlbmRlcmVyKHtcbiAgICAgICAgICAgIHRvVHJlZTogKGluc3QpID0+IHRvVHJlZShpbnN0Ll9yZWFjdEludGVybmFsRmliZXIpLFxuICAgICAgICAgICAgZ2V0TW91bnRXcmFwcGVySW5zdGFuY2U6ICgpID0+IGluc3RhbmNlLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC4uLihpczE2OCAmJiB7IHdyYXBJbnZva2U6IHdyYXBBY3QgfSksXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZVNoYWxsb3dSZW5kZXJlcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcztcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcbiAgICBjb25zdCB7IHN1c3BlbnNlRmFsbGJhY2sgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzdXNwZW5zZUZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc3VzcGVuc2VGYWxsYmFjayAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2BvcHRpb25zLnN1c3BlbnNlRmFsbGJhY2tgIHNob3VsZCBiZSBib29sZWFuIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBsZXQgaXNET00gPSBmYWxzZTtcbiAgICBsZXQgY2FjaGVkTm9kZSA9IG51bGw7XG5cbiAgICBsZXQgbGFzdENvbXBvbmVudCA9IG51bGw7XG4gICAgbGV0IHdyYXBwZWRDb21wb25lbnQgPSBudWxsO1xuICAgIGNvbnN0IHNlbnRpbmVsID0ge307XG5cbiAgICAvLyB3cmFwIG1lbW8gY29tcG9uZW50cyB3aXRoIGEgUHVyZUNvbXBvbmVudCwgb3IgYSBjbGFzcyBjb21wb25lbnQgd2l0aCBzQ1VcbiAgICBjb25zdCB3cmFwUHVyZUNvbXBvbmVudCA9IChDb21wb25lbnQsIGNvbXBhcmUpID0+IHtcbiAgICAgIGlmICghaXMxNjYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gUmVhY3QgPCAxNi42LiBQbGVhc2UgcmVwb3J0IHRoaXMhJyk7XG4gICAgICB9XG4gICAgICBpZiAobGFzdENvbXBvbmVudCAhPT0gQ29tcG9uZW50KSB7XG4gICAgICAgIGlmIChpc1N0YXRlZnVsKENvbXBvbmVudCkpIHtcbiAgICAgICAgICB3cmFwcGVkQ29tcG9uZW50ID0gY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQge307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvblxuICAgICAgICAgIGlmIChjb21wYXJlKSB7XG4gICAgICAgICAgICB3cmFwcGVkQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSAobmV4dFByb3BzKSA9PiAhY29tcGFyZSh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVkQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBtZW1vaXplZCA9IHNlbnRpbmVsO1xuICAgICAgICAgIGxldCBwcmV2UHJvcHM7XG4gICAgICAgICAgd3JhcHBlZENvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkVXBkYXRlID0gbWVtb2l6ZWQgPT09IHNlbnRpbmVsIHx8IChjb21wYXJlXG4gICAgICAgICAgICAgID8gIWNvbXBhcmUocHJldlByb3BzLCBwcm9wcylcbiAgICAgICAgICAgICAgOiAhc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgcHJvcHMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICBtZW1vaXplZCA9IENvbXBvbmVudCh7IC4uLkNvbXBvbmVudC5kZWZhdWx0UHJvcHMsIC4uLnByb3BzIH0sIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICBwcmV2UHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgd3JhcHBlZENvbXBvbmVudCxcbiAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgeyBkaXNwbGF5TmFtZTogYWRhcHRlci5kaXNwbGF5TmFtZU9mTm9kZSh7IHR5cGU6IENvbXBvbmVudCB9KSB9LFxuICAgICAgICApO1xuICAgICAgICBsYXN0Q29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZWRDb21wb25lbnQ7XG4gICAgfTtcblxuICAgIC8vIFdyYXAgZnVuY3Rpb25hbCBjb21wb25lbnRzIG9uIHZlcnNpb25zIHByaW9yIHRvIDE2LjUsXG4gICAgLy8gdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBwYXNzIGEgYHRoaXNgIGluc3RhbmNlIHRvIGl0LlxuICAgIGNvbnN0IHdyYXBGdW5jdGlvbmFsQ29tcG9uZW50ID0gKENvbXBvbmVudCkgPT4ge1xuICAgICAgaWYgKGlzMTY2ICYmIGhhcyhDb21wb25lbnQsICdkZWZhdWx0UHJvcHMnKSkge1xuICAgICAgICBpZiAobGFzdENvbXBvbmVudCAhPT0gQ29tcG9uZW50KSB7XG4gICAgICAgICAgd3JhcHBlZENvbXBvbmVudCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgKHByb3BzLCAuLi5hcmdzKSA9PiBDb21wb25lbnQoeyAuLi5Db21wb25lbnQuZGVmYXVsdFByb3BzLCAuLi5wcm9wcyB9LCAuLi5hcmdzKSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHsgZGlzcGxheU5hbWU6IGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUoeyB0eXBlOiBDb21wb25lbnQgfSkgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGxhc3RDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZWRDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoaXMxNjUpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RDb21wb25lbnQgIT09IENvbXBvbmVudCkge1xuICAgICAgICB3cmFwcGVkQ29tcG9uZW50ID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAoLi4uYXJncykgPT4gQ29tcG9uZW50KC4uLmFyZ3MpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICk7XG4gICAgICAgIGxhc3RDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlZENvbXBvbmVudDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcihlbCwgdW5tYXNrZWRDb250ZXh0LCB7XG4gICAgICAgIHByb3ZpZGVyVmFsdWVzID0gbmV3IE1hcCgpLFxuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNhY2hlZE5vZGUgPSBlbDtcbiAgICAgICAgLyogZXNsaW50IGNvbnNpc3RlbnQtcmV0dXJuOiAwICovXG4gICAgICAgIGlmICh0eXBlb2YgZWwudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpc0RPTSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb250ZXh0UHJvdmlkZXIoZWwpKSB7XG4gICAgICAgICAgcHJvdmlkZXJWYWx1ZXMuc2V0KGVsLnR5cGUsIGVsLnByb3BzLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBNb2NrUHJvdmlkZXIgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgKHByb3BzKSA9PiBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgIGVsLnR5cGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJlci5yZW5kZXIoeyAuLi5lbCwgdHlwZTogTW9ja1Byb3ZpZGVyIH0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0NvbnRleHRDb25zdW1lcihlbCkpIHtcbiAgICAgICAgICBjb25zdCBQcm92aWRlciA9IGFkYXB0ZXIuZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIoZWwudHlwZSk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlclZhbHVlcy5oYXMoUHJvdmlkZXIpXG4gICAgICAgICAgICA/IHByb3ZpZGVyVmFsdWVzLmdldChQcm92aWRlcilcbiAgICAgICAgICAgIDogZ2V0UHJvdmlkZXJEZWZhdWx0VmFsdWUoUHJvdmlkZXIpO1xuICAgICAgICAgIGNvbnN0IE1vY2tDb25zdW1lciA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAocHJvcHMpID0+IHByb3BzLmNoaWxkcmVuKHZhbHVlKSxcbiAgICAgICAgICAgIGVsLnR5cGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJlci5yZW5kZXIoeyAuLi5lbCwgdHlwZTogTW9ja0NvbnN1bWVyIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0RPTSA9IGZhbHNlO1xuICAgICAgICAgIGxldCByZW5kZXJlZEVsID0gZWw7XG4gICAgICAgICAgaWYgKGlzTGF6eShyZW5kZXJlZEVsKSkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdgUmVhY3QubGF6eWAgaXMgbm90IHN1cHBvcnRlZCBieSBzaGFsbG93IHJlbmRlcmluZy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzU3VzcGVuc2UocmVuZGVyZWRFbCkpIHtcbiAgICAgICAgICAgIGxldCB7IGNoaWxkcmVuIH0gPSByZW5kZXJlZEVsLnByb3BzO1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBmYWxsYmFjayB9ID0gcmVuZGVyZWRFbC5wcm9wcztcbiAgICAgICAgICAgICAgY2hpbGRyZW4gPSByZXBsYWNlTGF6eVdpdGhGYWxsYmFjayhjaGlsZHJlbiwgZmFsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgRmFrZVN1c3BlbnNlV3JhcHBlciA9ICgpID0+IGNoaWxkcmVuO1xuICAgICAgICAgICAgcmVuZGVyZWRFbCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmFrZVN1c3BlbnNlV3JhcHBlciwgbnVsbCwgY2hpbGRyZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCB9ID0gcmVuZGVyZWRFbDtcblxuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KENvbXBvbmVudC5jb250ZXh0VHlwZXMsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoaXNNZW1vKGVsLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGU6IElubmVyQ29tcCwgY29tcGFyZSB9ID0gZWwudHlwZTtcblxuICAgICAgICAgICAgcmV0dXJuIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4gcmVuZGVyZXIucmVuZGVyKFxuICAgICAgICAgICAgICB7IC4uLmVsLCB0eXBlOiB3cmFwUHVyZUNvbXBvbmVudChJbm5lckNvbXAsIGNvbXBhcmUpIH0sXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzU3RhdGVmdWwoQ29tcG9uZW50KSAmJiB0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJlci5yZW5kZXIoXG4gICAgICAgICAgICAgIHsgLi4ucmVuZGVyZWRFbCwgdHlwZTogd3JhcEZ1bmN0aW9uYWxDb21wb25lbnQoQ29tcG9uZW50KSB9LFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzU3RhdGVmdWwpIHtcbiAgICAgICAgICAgIC8vIGZpeCByZWFjdCBidWc7IHNlZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0RW1wdHlTdGF0ZVZhbHVlYFxuICAgICAgICAgICAgY29uc3QgZW1wdHlTdGF0ZVZhbHVlID0gZ2V0RW1wdHlTdGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoZW1wdHlTdGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCAnc3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZW1wdHlTdGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHJlbmRlcmVyLnJlbmRlcihyZW5kZXJlZEVsLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICByZW5kZXJlci51bm1vdW50KCk7XG4gICAgICB9LFxuICAgICAgZ2V0Tm9kZSgpIHtcbiAgICAgICAgaWYgKGlzRE9NKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRUb1RyZWUoY2FjaGVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyT3V0cHV0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZVR5cGU6IG5vZGVUeXBlRnJvbVR5cGUoY2FjaGVkTm9kZS50eXBlKSxcbiAgICAgICAgICB0eXBlOiBjYWNoZWROb2RlLnR5cGUsXG4gICAgICAgICAgcHJvcHM6IGNhY2hlZE5vZGUucHJvcHMsXG4gICAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChjYWNoZWROb2RlLmtleSksXG4gICAgICAgICAgcmVmOiBjYWNoZWROb2RlLnJlZixcbiAgICAgICAgICBpbnN0YW5jZTogcmVuZGVyZXIuX2luc3RhbmNlLFxuICAgICAgICAgIHJlbmRlcmVkOiBBcnJheS5pc0FycmF5KG91dHB1dClcbiAgICAgICAgICAgID8gZmxhdHRlbihvdXRwdXQpLm1hcCgoZWwpID0+IGVsZW1lbnRUb1RyZWUoZWwpKVxuICAgICAgICAgICAgOiBlbGVtZW50VG9UcmVlKG91dHB1dCksXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFcnJvcihub2RlSGllcmFyY2h5LCByb290Tm9kZSwgZXJyb3IpIHtcbiAgICAgICAgc2ltdWxhdGVFcnJvcihcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZW5kZXJlci5faW5zdGFuY2UsXG4gICAgICAgICAgY2FjaGVkTm9kZSxcbiAgICAgICAgICBub2RlSGllcmFyY2h5LmNvbmNhdChjYWNoZWROb2RlKSxcbiAgICAgICAgICBub2RlVHlwZUZyb21UeXBlLFxuICAgICAgICAgIGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUsXG4gICAgICAgICAgaXMxNjYgPyBjYWNoZWROb2RlLnR5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFdmVudChub2RlLCBldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gbm9kZS5wcm9wc1twcm9wRnJvbUV2ZW50KGV2ZW50LCBldmVudE9wdGlvbnMpXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE8obG1yKTogY3JlYXRlL3VzZSBzeW50aGV0aWMgZXZlbnRzXG4gICAgICAgICAgICAvLyBUT0RPKGxtcik6IGVtdWxhdGUgUmVhY3QncyBldmVudCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgLy8gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlciguLi5hcmdzKTtcbiAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIC8vIHJldHVybiBSZWFjdERPTS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyhmbik7XG4gICAgICB9LFxuICAgICAgY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBoaWVyYXJjaHkpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICAgIHR5cGVTcGVjcyxcbiAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgZGlzcGxheU5hbWVPZk5vZGUoY2FjaGVkTm9kZSksXG4gICAgICAgICAgKCkgPT4gZ2V0Q29tcG9uZW50U3RhY2soaGllcmFyY2h5LmNvbmNhdChbY2FjaGVkTm9kZV0pKSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZVN0cmluZ1JlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICBpZiAoaGFzKG9wdGlvbnMsICdzdXNwZW5zZUZhbGxiYWNrJykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BzdXNwZW5zZUZhbGxiYWNrYCBzaG91bGQgbm90IGJlIHNwZWNpZmllZCBpbiBvcHRpb25zIG9mIHN0cmluZyByZW5kZXJlcicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRleHQgJiYgKGVsLnR5cGUuY29udGV4dFR5cGVzIHx8IG9wdGlvbnMuY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICAuLi4oZWwudHlwZS5jb250ZXh0VHlwZXMgfHwge30pLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5jaGlsZENvbnRleHRUeXBlcyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IENvbnRleHRXcmFwcGVyID0gY3JlYXRlUmVuZGVyV3JhcHBlcihlbCwgY29udGV4dCwgY2hpbGRDb250ZXh0VHlwZXMpO1xuICAgICAgICAgIHJldHVybiBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY01hcmt1cChSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRXcmFwcGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RhdGljTWFya3VwKGVsKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFByb3ZpZGVkIGEgYmFnIG9mIG9wdGlvbnMsIHJldHVybiBhbiBgRW56eW1lUmVuZGVyZXJgLiBTb21lIG9wdGlvbnMgY2FuIGJlIGltcGxlbWVudGF0aW9uXG4gIC8vIHNwZWNpZmljLCBsaWtlIGBhdHRhY2hgIGV0Yy4gZm9yIFJlYWN0LCBidXQgbm90IHBhcnQgb2YgdGhpcyBpbnRlcmZhY2UgZXhwbGljaXRseS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHN3aXRjaCAob3B0aW9ucy5tb2RlKSB7XG4gICAgICBjYXNlIEVuenltZUFkYXB0ZXIuTU9ERVMuTU9VTlQ6IHJldHVybiB0aGlzLmNyZWF0ZU1vdW50UmVuZGVyZXIob3B0aW9ucyk7XG4gICAgICBjYXNlIEVuenltZUFkYXB0ZXIuTU9ERVMuU0hBTExPVzogcmV0dXJuIHRoaXMuY3JlYXRlU2hhbGxvd1JlbmRlcmVyKG9wdGlvbnMpO1xuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLlNUUklORzogcmV0dXJuIHRoaXMuY3JlYXRlU3RyaW5nUmVuZGVyZXIob3B0aW9ucyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVuenltZSBJbnRlcm5hbCBFcnJvcjogVW5yZWNvZ25pemVkIG1vZGU6ICR7b3B0aW9ucy5tb2RlfWApO1xuICAgIH1cbiAgfVxuXG4gIHdyYXAoZWxlbWVudCkge1xuICAgIHJldHVybiB3cmFwKGVsZW1lbnQpO1xuICB9XG5cbiAgLy8gY29udmVydHMgYW4gUlNUTm9kZSB0byB0aGUgY29ycmVzcG9uZGluZyBKU1ggUHJhZ21hIEVsZW1lbnQuIFRoaXMgd2lsbCBiZSBuZWVkZWRcbiAgLy8gaW4gb3JkZXIgdG8gaW1wbGVtZW50IHRoZSBgV3JhcHBlci5tb3VudCgpYCBhbmQgYFdyYXBwZXIuc2hhbGxvdygpYCBtZXRob2RzLCBidXQgc2hvdWxkXG4gIC8vIGJlIHByZXR0eSBzdHJhaWdodGZvcndhcmQgZm9yIHBlb3BsZSB0byBpbXBsZW1lbnQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIG5vZGVUb0VsZW1lbnQobm9kZSkge1xuICAgIGlmICghbm9kZSB8fCB0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gbm9kZTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCh1bm1lbW9UeXBlKHR5cGUpLCBwcm9wc1dpdGhLZXlzQW5kUmVmKG5vZGUpKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIG1hdGNoZXNFbGVtZW50VHlwZShub2RlLCBtYXRjaGluZ1R5cGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBjb25zdCB7IHR5cGUgfSA9IG5vZGU7XG4gICAgcmV0dXJuIHVubWVtb1R5cGUodHlwZSkgPT09IHVubWVtb1R5cGUobWF0Y2hpbmdUeXBlKTtcbiAgfVxuXG4gIGVsZW1lbnRUb05vZGUoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50VG9UcmVlKGVsZW1lbnQpO1xuICB9XG5cbiAgbm9kZVRvSG9zdE5vZGUobm9kZSwgc3VwcG9ydHNBcnJheSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBub2RlVG9Ib3N0Tm9kZShub2RlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykgJiYgIXN1cHBvcnRzQXJyYXkpIHtcbiAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgZGlzcGxheU5hbWVPZk5vZGUobm9kZSkge1xuICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyB0eXBlLCAkJHR5cGVvZiB9ID0gbm9kZTtcblxuICAgIGNvbnN0IG5vZGVUeXBlID0gdHlwZSB8fCAkJHR5cGVvZjtcblxuICAgIC8vIG5ld2VyIG5vZGUgdHlwZXMgbWF5IGJlIHVuZGVmaW5lZCwgc28gb25seSB0ZXN0IGlmIHRoZSBub2RlVHlwZSBleGlzdHNcbiAgICBpZiAobm9kZVR5cGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSAoaXMxNjYgPyBDb25jdXJyZW50TW9kZSA6IEFzeW5jTW9kZSkgfHwgTmFOOiByZXR1cm4gaXMxNjYgPyAnQ29uY3VycmVudE1vZGUnIDogJ0FzeW5jTW9kZSc7XG4gICAgICAgIGNhc2UgRnJhZ21lbnQgfHwgTmFOOiByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICAgICAgY2FzZSBTdHJpY3RNb2RlIHx8IE5hTjogcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICAgICAgY2FzZSBQcm9maWxlciB8fCBOYU46IHJldHVybiAnUHJvZmlsZXInO1xuICAgICAgICBjYXNlIFBvcnRhbCB8fCBOYU46IHJldHVybiAnUG9ydGFsJztcbiAgICAgICAgY2FzZSBTdXNwZW5zZSB8fCBOYU46IHJldHVybiAnU3VzcGVuc2UnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICBjYXNlIENvbnRleHRDb25zdW1lciB8fCBOYU46IHJldHVybiAnQ29udGV4dENvbnN1bWVyJztcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyIHx8IE5hTjogcmV0dXJuICdDb250ZXh0UHJvdmlkZXInO1xuICAgICAgY2FzZSBNZW1vIHx8IE5hTjoge1xuICAgICAgICBjb25zdCBub2RlTmFtZSA9IGRpc3BsYXlOYW1lT2ZOb2RlKG5vZGUpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG5vZGVOYW1lID09PSAnc3RyaW5nJyA/IG5vZGVOYW1lIDogYE1lbW8oJHtkaXNwbGF5TmFtZU9mTm9kZSh0eXBlKX0pYDtcbiAgICAgIH1cbiAgICAgIGNhc2UgRm9yd2FyZFJlZiB8fCBOYU46IHtcbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gZGlzcGxheU5hbWVPZk5vZGUoeyB0eXBlOiB0eXBlLnJlbmRlciB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBgRm9yd2FyZFJlZigke25hbWV9KWAgOiAnRm9yd2FyZFJlZic7XG4gICAgICB9XG4gICAgICBjYXNlIExhenkgfHwgTmFOOiB7XG4gICAgICAgIHJldHVybiAnbGF6eSc7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiByZXR1cm4gZGlzcGxheU5hbWVPZk5vZGUobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoZWxlbWVudCk7XG4gIH1cblxuICBpc1ZhbGlkRWxlbWVudFR5cGUob2JqZWN0KSB7XG4gICAgcmV0dXJuICEhb2JqZWN0ICYmIGlzVmFsaWRFbGVtZW50VHlwZShvYmplY3QpO1xuICB9XG5cbiAgaXNGcmFnbWVudChmcmFnbWVudCkge1xuICAgIHJldHVybiB0eXBlT2ZOb2RlKGZyYWdtZW50KSA9PT0gRnJhZ21lbnQ7XG4gIH1cblxuICBpc0N1c3RvbUNvbXBvbmVudCh0eXBlKSB7XG4gICAgY29uc3QgZmFrZUVsZW1lbnQgPSBtYWtlRmFrZUVsZW1lbnQodHlwZSk7XG4gICAgcmV0dXJuICEhdHlwZSAmJiAoXG4gICAgICB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgfHwgaXNGb3J3YXJkUmVmKGZha2VFbGVtZW50KVxuICAgICAgfHwgaXNDb250ZXh0UHJvdmlkZXIoZmFrZUVsZW1lbnQpXG4gICAgICB8fCBpc0NvbnRleHRDb25zdW1lcihmYWtlRWxlbWVudClcbiAgICAgIHx8IGlzU3VzcGVuc2UoZmFrZUVsZW1lbnQpXG4gICAgKTtcbiAgfVxuXG4gIGlzQ29udGV4dENvbnN1bWVyKHR5cGUpIHtcbiAgICByZXR1cm4gISF0eXBlICYmIGlzQ29udGV4dENvbnN1bWVyKG1ha2VGYWtlRWxlbWVudCh0eXBlKSk7XG4gIH1cblxuICBpc0N1c3RvbUNvbXBvbmVudEVsZW1lbnQoaW5zdCkge1xuICAgIGlmICghaW5zdCB8fCAhdGhpcy5pc1ZhbGlkRWxlbWVudChpbnN0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0N1c3RvbUNvbXBvbmVudChpbnN0LnR5cGUpO1xuICB9XG5cbiAgZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIoQ29uc3VtZXIpIHtcbiAgICAvLyBSZWFjdCBzdG9yZXMgcmVmZXJlbmNlcyB0byB0aGUgUHJvdmlkZXIgb24gYSBDb25zdW1lciBkaWZmZXJlbnRseSBhY3Jvc3MgdmVyc2lvbnMuXG4gICAgaWYgKENvbnN1bWVyKSB7XG4gICAgICBsZXQgUHJvdmlkZXI7XG4gICAgICBpZiAoQ29uc3VtZXIuX2NvbnRleHQpIHsgLy8gY2hlY2sgdGhpcyBmaXJzdCwgdG8gYXZvaWQgYSBkZXByZWNhdGlvbiB3YXJuaW5nXG4gICAgICAgICh7IFByb3ZpZGVyIH0gPSBDb25zdW1lci5fY29udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKENvbnN1bWVyLlByb3ZpZGVyKSB7XG4gICAgICAgICh7IFByb3ZpZGVyIH0gPSBDb25zdW1lcik7XG4gICAgICB9XG4gICAgICBpZiAoUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb3ZpZGVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuenltZSBJbnRlcm5hbCBFcnJvcjogY2Fu4oCZdCBmaWd1cmUgb3V0IGhvdyB0byBnZXQgUHJvdmlkZXIgZnJvbSBDb25zdW1lcicpO1xuICB9XG5cbiAgY3JlYXRlRWxlbWVudCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoLi4uYXJncyk7XG4gIH1cblxuICB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50KG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgUm9vdEZpbmRlcixcbiAgICAgIG5vZGU6IHdyYXBXaXRoV3JhcHBpbmdDb21wb25lbnQoUmVhY3QuY3JlYXRlRWxlbWVudCwgbm9kZSwgb3B0aW9ucyksXG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2l4dGVlbkFkYXB0ZXI7XG4iXX0=
//# sourceMappingURL=ReactSixteenAdapter.js.map